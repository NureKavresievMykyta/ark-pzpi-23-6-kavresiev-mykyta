МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
до лабораторної роботи №2
з дисципліни «Аналіз та рефакторинг коду» на тему:
«РОЗРОБКА БАЗИ ДАНИХ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ ТА ПРИКЛАДНОГО ПРОГРАМНОГО ІНТЕРФЕЙСУ (API)»



Виконав:
ст. гр. ПЗПІ-23-6
Кавресєв Микита


Перевірив:
ас. кафедри ПІ
Дашенков Дмитро Сергійович



Харків 2025
1 ЗАВДАННЯ
     Мета роботи: ознайомлення з процесом розробки серверної частини програмної системи, включаючи проєктування бази даних, розробку API та перевірку їхньої взаємодії.
     Завдання включає:
1. Розробити будову програмної системи (архітектура, моделі);
2. Створити UML діаграму прецедентів для серверної частини;
3. Створити ER діаграму даних;
4. Розробити базу даних (БД) та описати схему нормалізаці;
5. Створити діаграму структури БД;
6. Розробити функції роботи з БД (ORM);
7. Розробити REST API для взаємодії з клієнтами;
8. Створити специфікацію API;
9. Перевірити роботу створеного програмного коду (тестування).


2 ОПИС ВИКОНАНОЇ РОБОТИ
     2.1 Архітектурні рішення та будова системи
     Програмна система OptiView (інформаційна система для офтальмологічних клінік) спроєктована на основі клієнт-серверної архітектури. Серверна частина виконує роль центрального вузла обробки даних, забезпечуючи бізнес-логіку, безпеку та зберігання інформації.
     Технологічний стек:
* Мова програмування: Java 17;
* Фреймворк: Spring Boot (забезпечує DI, MVC архітектуру, безпеку та швидку розробку REST API);
* База даних: PostgreSQL (розгорнута на хмарній платформі Supabase). Це потужна об'єктно-реляційна СУБД, що підтримує складні запити та транзакції;
* ORM: Hibernate (Spring Data JPA) - для об'єктно-реляційного відображення, що дозволяє працювати з БД через Java-класи;
* Збірка проєкту: Maven;
* Документація API: SpringDoc OpenAPI (Swagger UI).
     Архітектурний патерн: Використано патерн MVC (Model-View-Controller) у форматі REST API, де:
* Model (Entity): Класи Java, що відображають таблиці БД;
* Repository: Інтерфейси для доступу до даних (DAO шар);
* Controller: Класи, що обробляють HTTP-запити та повертають JSON-відповіді.
     2.2 Моделювання системи (UML та ER діаграми)
     2.2.1 UML діаграма прецедентів серверної частини
     Діаграма відображає основні сценарії використання серверної частини акторами системи (Адміністратор, Лікар, Пацієнт, IoT-пристрій). Основні прецеденти включають автентифікацію, управління розкладом, проведення огляду та парсинг даних з приладів.
     
     
Рисунок 2.1 - UML діаграма прецедентів
     2.2.2 ER діаграма даних
     Розроблено ER-діаграму, що визначає сутності та зв'язки. Ключові сутності:
* User - базовий користувач (логін, пароль, роль);
* Doctor / Admin / Patient - розширення профілів користувачів;
* Visit - візит пацієнта (зв'язує лікаря та пацієнта);
* MedicalRecord - результати огляду;
* Measurement - детальні вимірювання (IoT дані).
     Зв'язки побудовані для забезпечення цілісності даних (наприклад, один Пацієнт може мати багато Візитів, один Візит містить один Медичний запис).
     
     
Рисунок 2.2 – ER діаграма даних
     2.2.3 Діаграма структури БД 
     Фізична реалізація БД виконана в PostgreSQL (Supabase). Усі таблиці нормалізовані, встановлено первинні (PK) та зовнішні (FK) ключі.


Рисунок 2.3 – Діаграма структури БД
     Нормалізація даних: База даних спроєктована з дотриманням правил нормалізації до 3NF (Третя нормальна форма):
1. 1NF: Всі атрибути атомарні, відсутні групи, що повторюються. Кожна таблиця має унікальний ключ;
2. 2NF: Таблиці знаходяться в 1NF, всі неключові атрибути залежать від повного первинного ключа. Дані винесені в окремі таблиці (doctors, patients, diagnoses);
3. 3NF: Відсутні транзитивні залежності. Наприклад, назва діагнозу залежить від його коду, тому діагнози винесені в довідник diagnoses, а в записі огляду зберігається лише ID.
     2.3 Розробка функцій роботи з БД (ORM Implementation)
     Взаємодія з базою даних реалізована через Spring Data JPA (Hibernate). Це дозволило уникнути написання SQL-запитів вручну для стандартних операцій.
     Приклад Entity-класу (Patient.java): Клас описує структуру таблиці patients. Анотації JPA (@Entity, @Id, @Column) пов'язують поля класу з колонками таблиці.
@Data
@Entity
@Table(name = "patients")
public class Patient {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "patient_id")
    private Long patientId;

    @Column(name = "first_name", nullable = false)
    private String firstName;

    @Column(name = "last_name", nullable = false)
    private String lastName;

    @Column(name = "phone")
    private String phone;
}
     Клас Patient є відображенням структури бази даних у програмному коді. Анотація @Entity визначає цей клас як сутність JPA, а @Table прив'язує його до конкретної таблиці "patients". Для поля первинного ключа використано стратегію GenerationType.IDENTITY, що відповідає автоінкременту (AUTO_INCREMENT) у базі даних, дозволяючи системі автоматично генерувати унікальні ID для нових пацієнтів.
     Також варто відзначити використання анотації @Data з бібліотеки Lombok. Вона автоматично генерує необхідний шаблонний код (геттери, сеттери, методи toString, equals та hashcode) під час компіляції, що робить вихідний код чистішим і компактнішим.
     Приклад Repository (PatientRepository.java): Інтерфейс розширює JpaRepository, що автоматично надає методи CRUD (save, findAll, findById, delete).
@Repository
public interface PatientRepository extends JpaRepository<Patient, Long> {
}
     Інтерфейс PatientRepository демонструє принцип абстракції рівня доступу до даних. Завдяки наслідуванню від JpaRepository<Patient, Long>, розробнику не потрібно писати SQL-запити вручну. У параметрах типізації вказано клас сутності (Patient) та тип її первинного ключа (Long). Під час запуску додатка Spring Data автоматично створює реалізацію цього інтерфейсу (proxy-клас), надаючи готовий набір методів для виконання стандартних операцій з базою даних.
     2.4 Розробка API та взаємодія з клієнтами
     Для взаємодії з клієнтами (веб-сайт, мобільний додаток) розроблено REST API. Обмін даними відбувається у форматі JSON.
     Контролер (PatientController.java): Клас обробляє HTTP-запити. Реалізовано методи GET, POST, PUT, DELETE.
package ua.nure.kavresiev.optiview.controller;

import ua.nure.kavresiev.optiview.entity.Patient;
import ua.nure.kavresiev.optiview.repository.PatientRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/patients")
public class PatientController {

    @Autowired
    private PatientRepository patientRepository;

    @GetMapping
    public List<Patient> getAllPatients() {
        return patientRepository.findAll();
    }

    @PostMapping
    public Patient createPatient(@RequestBody Patient patient) {
        return patientRepository.save(patient);
    }

    @PutMapping("/{id}")
    public Patient updatePatient(@PathVariable Long id, @RequestBody Patient details) {
        Patient patient = patientRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Patient not found with id: " + id));

        patient.setFirstName(details.getFirstName());
        patient.setLastName(details.getLastName());
        patient.setBirthDate(details.getBirthDate());
        patient.setPhone(details.getPhone());
        patient.setEmail(details.getEmail());
        patient.setAddress(details.getAddress());

        return patientRepository.save(patient);
    }

    @DeleteMapping("/{id}")
    public void deletePatient(@PathVariable Long id) {
        patientRepository.deleteById(id);
    }
}
     У наведеному лістингу анотація @RestController вказує фреймворку Spring, що даний клас відповідає за обробку вхідних REST-запитів і автоматично формує відповіді у форматі JSON. Анотація @RequestMapping задає єдину точку входу для всіх методів цього контролера.
     Зв'язок з рівнем даних реалізується через поле patientRepository, яке ініціалізується автоматично завдяки механізму впровадження залежностей (@Autowired). Методи контролера чітко розмежовані за функціоналом: @GetMapping відповідає за зчитування даних з бази, а @PostMapping обробляє запити на створення нових записів, при цьому анотація @RequestBody десеріалізує вхідний JSON-об'єкт у Java-об'єкт класу Patient.
     2.5 Специфікація розробленого API
     Для автоматичної генерації документації використано бібліотеку SpringDoc OpenAPI (Swagger). Нижче наведено специфікацію основних ендпоінтів системи.
     Базова URL: http://localhost:8080/api
     
     Рисунок 2.4 – Інтерфейс Swagger UI для тестування API
     
Таблиця 2.1 - Тестування AdminController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/adminsОтримання списку всіх адміністраторівСписок об'єктів JSON200 OKPOST/api/adminsСтворення нового адміністратораСтворений об'єкт201 CreatedGET/api/admins/{id}Пошук адміністратора за IDДані конкретного адміна200 OKDELETE/api/admins/{id}Видалення адміністратораПорожнє тіло відповіді200 OK
Таблиця 2.2 - Тестування DiagnosisController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/diagnosesОтримання довідника діагнозівСписок діагнозів200 OKPOST/api/diagnosesДодавання нового діагнозуНовий діагноз у базі201 CreatedPUT/api/diagnoses/{id}Редагування назви діагнозуОновлені дані200 OKDELETE/api/diagnoses/{id}Видалення діагнозу з довідникаУспішне видалення200 OK
Таблиця 2.3 - Тестування DoctorController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/doctorsПерегляд списку лікарівМасив даних про лікарів200 OKPOST/api/doctorsРеєстрація лікаря в системіСтворений профіль лікаря201 CreatedGET/api/doctors/{id}Перегляд профілю конкретного лікаряДетальна інформація200 OKPUT/api/doctors/{id}Оновлення даних лікаряЗмінені дані збережено200 OK
Таблиця 2.4 - Тестування MeasurementController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/measurementsОтримання списку вимірюваньІсторія вимірювань200 OKPOST/api/measurementsВнесення результатів вимірюваньЗапис збережено201 CreatedGET/api/measurements/{id}Перегляд конкретного вимірюванняДані вимірювання200 OKDELETE/api/measurements/{id}Видалення помилкового записуЗапис видалено200 OK
Таблиця 2.5 - Тестування MedicalRecordController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/medical-recordsОтримання медичних картокСписок карток200 OKPOST/api/medical-recordsСтворення нової медкартиКартка створена201 CreatedPUT/api/medical-records/{id}Оновлення записів у картціДані оновлено200 OKDELETE/api/medical-records/{id}Видалення медичної карткиКартку видалено200 OK
Таблиця 2.6 - Тестування PatientController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/patientsВиведення всіх пацієнтівСписок пацієнтів200 OKPOST/api/patientsРеєстрація нового пацієнтаПрофіль створено201 CreatedGET/api/patients/{id}Отримання даних пацієнтаОсобисті дані200 OKPUT/api/patients/{id}Редагування профілю пацієнтаЗміни прийнято200 OK
Таблиця 2.7 - Тестування PrescriptionController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/prescriptionsПерегляд виписаних рецептівСписок рецептів200 OKPOST/api/prescriptionsСтворення призначенняПризначення додано201 CreatedGET/api/prescriptions/{id}Деталі рецептуІнформація про ліки200 OKDELETE/api/prescriptions/{id}Скасування призначенняЗапис видалено200 OK
Таблиця 2.8 - Тестування RecordDiagnosisController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/record-diagnosesПерегляд зв'язків записів і діагнозівСписок записів200 OKPOST/api/record-diagnosesПрив'язка діагнозу до записуЗв'язок створено201 CreatedPUT/api/record-diagnoses/{id}Коригування діагнозу в записіЗміни збережено200 OKDELETE/api/record-diagnoses/{id}Видалення діагнозу із записуЗв'язок розірвано200 OK
Таблиця 2.9 - Тестування UserController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/usersОтримання системних користувачівСписок логінів/ролей200 OKPOST/api/usersСтворення користувачаКористувач доданий201 CreatedPUT/api/users/{id}Зміна паролю або роліДані оновлено200 OKDELETE/api/users/{id}Блокування/видалення користувачаДоступ закрито200 OK

Таблиця 2.10 - Тестування VisitController
МетодURL-адресаОпис діїОчікуваний результатСтатусGET/api/visitsРозклад візитівСписок запланованих візитів200 OKPOST/api/visitsЗапис на прийомВізит створено201 CreatedGET/api/visits/{id}Деталі візитуЧас та лікар200 OKDELETE/api/visits/{id}Скасування візитуВізит видалено200 OK     2.6 Перевірка роботи програмного коду (Тестування)
     1. Створення нового користувача та профілю лікаря (POST)
Спочатку необхідно зареєструвати в системі нового користувача, який матиме відповідні права доступу. Для цього я відправив POST-запит, у тілі якого передав необхідні дані для створення профілю лікаря, включаючи його спеціалізацію та контактну інформацію. Сервер успішно обробив запит і створив новий запис у базі даних.

Рисунок 2.5 – Результат виконання створення нового користувача вибравши роль «Доктор»


Рисунок 2.6 – Результат виконання запиту створення лікаря на основі користувача
     2. Створення пацієнта (POST)
     Після налаштування профілю лікаря я перейшов до створення картки пацієнта. Використовуючи відповідний контролер, я надіслав дані про нову особу: ім'я, прізвище та номер телефону. У відповідь отримав підтвердження зі статусом 200 OK, що свідчить про успішне додавання пацієнта до реєстру.

     Рисунок 2.7 - Успішна реєстрація нового пацієнта в системі

     3. Пацієнта записано на візит (POST)
     Наступним кроком було тестування взаємозв'язку між таблицями. Я створив новий візит, зв'язавши раніше створеного лікаря та пацієнта за їхніми унікальними ідентифікаторами (ID). У запиті також було вказано дату та час прийому. Це дозволило перевірити роботу VisitController.

Рисунок 2.8 - Створення запису на прийом через POST-запит

     4. Отримано список візитів (GET)
     Щоб переконатися, що запис на прийом дійсно зберігся в базі даних, я виконав GET-запит для отримання повного списку візитів. У отриманому JSON-масиві відобразився щойно створений об'єкт із коректними даними про лікаря та пацієнта.
     
Рисунок 2.9 - Перегляд списку запланованих візитів

     5. Оновлено дані пацієнта (PUT)
     В ході експлуатації системи дані можуть змінюватися, тому я протестував функцію редагування. Я відправив PUT-запит для зміни контактного номера телефону пацієнта. Сервер повернув оновлений об'єкт, і повторна перевірка підтвердила, що зміни успішно застосовані.

Рисунок 2.10 - Оновлення контактної інформації пацієнта

     6. Видалено тестовий запис (DELETE)
     Завершальним етапом стала перевірка можливості видалення даних. Я використав метод DELETE для видалення створеного тестового візиту за його ID. Сервер повернув статус 200 OK, а запис зник із загального списку, що підтверджує коректну роботу функції очищення даних.

     Рисунок 2.10 - Видалення запису про візит із бази даних
     

Рисунок 2.11 – Перевірка видаленого запиту с id2
3 ВИСНОВКИ
     У ході виконання лабораторної роботи було успішно спроєктовано та реалізовано серверну частину інформаційної системи OptiView.
     Основні результати:
1. Розроблено архітектуру системи на базі Java Spring Boot, що забезпечує масштабованість та надійність;
2. Спроєктовано реляційну базу даних PostgreSQL з дотриманням 3-ї нормальної форми. Структура БД включає всі необхідні сутності для офтальмології (пацієнти, лікарі, вимірювання, рецепти);
3. Реалізовано доступ до даних через ORM Hibernate, що дозволило працювати з базою на рівні об'єктів Java;
4. Розроблено повноцінний REST API, який підтримує всі типи HTTP-запитів (GET, POST, PUT, DELETE) для керування даними клініки;
5. Створено інтерактивну документацію за допомогою Swagger/OpenAPI;
6. Проведено тестування системи через Postman, яке підтвердило коректність роботи всіх ендпоінтів та стабільну взаємодію з хмарною базою даних.
   Отримані результати повністю відповідають поставленому завданню та готові до інтеграції з клієнтськими додатками.


ДОДАТОК А
Посилання на відео-демонстрацію: https://youtu.be/v-cnMJRQtg8

Хронологічний опис:
00:55 - Вступ та огляд структури 
02:50 - Демонстрація API та роботи з БД

Посилання на GitHub репозиторій: https://github.com/NureKavresievMykyta/OptiView



2










