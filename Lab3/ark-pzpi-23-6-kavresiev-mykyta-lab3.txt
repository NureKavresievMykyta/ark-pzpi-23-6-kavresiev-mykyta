МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
до лабораторної роботи №3
з дисципліни «Аналіз та рефакторинг коду» на тему:
«РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ»



Виконав:
ст. гр. ПЗПІ-23-6
Кавресєв Микита


Перевірив:
ас. кафедри ПІ
Дашенков Дмитро Сергійович



Харків 2025
1 ЗАВДАННЯ
     Мета роботи: ознайомитися з процесом розробки бізнес-логіки та функцій адміністрування серверної частини програмної системи. Отримати практичні навички реалізації алгоритмів обробки даних, управління правами доступу, створення UML-діаграм діяльності та взаємодії, а також тестування серверної частини системи OptiView.
     План виконання роботи
1. Спроектувати алгоритми бізнес-логіки: Розробити сценарії обробки медичних даних, визначити правила валідації діагнозів та автоматизації статусів візитів;
2. Розробити функції адміністрування: Визначити механізми управління обліковими записами користувачів, включаючи блокування доступу та розподіл ролей;
3. Програмна реалізація серверної частини:
* Реалізувати шар сервісів (Service Layer) для обробки бізнес-правил;
* Реалізувати REST-контролери для взаємодії з клієнтською частиною;
* Забезпечити взаємодію з базою даних Supabase через репозиторії.
4. Перевірка роботи системи: Провести тестування розроблених кінцевих точок (API Endpoints) за допомогою інструменту налагодження Postman.


2 ХІД ВИКОНАННЯ РОБОТИ
     3.1. Текстовий опис інженерних рішень
     Серверна частина системи OptiView розроблена на базі мови програмування Java з використанням фреймворку Spring Boot. Цей вибір забезпечує надійність, масштабованість та швидкість розробки завдяки вбудованому контейнеру сервлетів та потужній екосистемі Dependency Injection.
     Архітектура системи: Використано класичну трирівневу архітектуру (Layered Architecture):
* Controller Layer (REST API): Відповідає за прийом HTTP-запитів та повернення відповідей у форматі JSON;
* Service Layer (Business Logic): Містить основні алгоритми обробки даних, валідацію та бізнес-правила;
* Repository Layer (Data Access): Забезпечує абстракцію доступу до даних через інтерфейс JpaRepository.
     Збереження даних: у якості системи управління базами даних використано хмарну платформу Supabase (PostgreSQL). Це дозволяє забезпечити доступність даних з будь-якої точки, автоматичне резервне копіювання та високу надійність зберігання медичних записів. Підключення реалізовано через стандартний драйвер PostgreSQL та Hibernate ORM.
     3.2. Програмна реалізація бізнес-логіки
     Основним елементом бізнес-логіки є обробка візитів пацієнтів. Реалізовано сервіс MedicalRecordService, який забезпечує валідацію вхідних даних та автоматичне заповнення системних полів.

     Алгоритм обробки візиту:
1. Лікар відправляє дані через DTO (Data Transfer Object);
2. Система перевіряє наявність обов'язкового поля "Діагноз". Якщо воно відсутнє — генерується виключення, і запис не зберігається (захист від некоректних даних);
3. Автоматично фіксується час початку та завершення прийому (LocalDateTime), а також встановлюється статус візиту COMPLETED.
Фрагмент коду класу MedicalRecordService.java:
@Service
public class MedicalRecordService {

    private final VisitRepository visitRepository;

    public MedicalRecordService(VisitRepository visitRepository) {
        this.visitRepository = visitRepository;
    }

    public Visit createVisit(VisitDTO visitDTO) {
        if (visitDTO.getDiagnosis() == null || visitDTO.getDiagnosis().isEmpty()) {
            throw new IllegalArgumentException("Diagnosis cannot be empty");
        }

        Visit visit = new Visit();
        mapDtoToEntity(visitDTO, visit);
        
        visit.setStartTime(LocalDateTime.now());
        visit.setEndTime(LocalDateTime.now().plusMinutes(20)); 
        visit.setVisitStatus("COMPLETED");
        visit.setVisitType("CONSULTATION");

        return visitRepository.save(visit);
    }
    
}
   Алгоритм обробки візиту (метод createVisit):
1. Прийом даних (DTO Mapping): Система отримує об'єкт VisitDTO, який містить лише дані, введені лікарем (ID пацієнта, діагноз, лікування, гострота зору). Це дозволяє ізолювати внутрішню структуру бази даних від зовнішнього інтерфейсу;
2. Валідація (Business Rules): Реалізовано перевірку на наявність діагнозу. Згідно з правилами клініки, візит не може бути збережений без встановленого діагнозу. У разі порушення цього правила система генерує виключення IllegalArgumentException, перериваючи обробку запиту;
3. Збагачення даних (Data Enrichment):
* Автоматично генерується часова мітка початку (startTime) та завершення (endTime) прийому (за замовчуванням встановлюється тривалість 20 хвилин);
* Присвоюється статус COMPLETED, що фіксує факт надання послуги.
* Встановлюється тип візиту CONSULTATION;
4. Персистентність: Підготовлений об'єкт сутності Visit передається у VisitRepository для збереження в хмарній базі даних Supabase.
Фрагмент реалізації методу:
public Visit createVisit(VisitDTO visitDTO) {
    if (visitDTO.getDiagnosis() == null || visitDTO.getDiagnosis().isEmpty()) {
        throw new IllegalArgumentException("Diagnosis cannot be empty");
    }
    Visit visit = new Visit();
    visit.setStartTime(LocalDateTime.now());
    visit.setVisitStatus("COMPLETED");
    return visitRepository.save(visit);
}
     3.3. Програмна реалізація функцій адміністрування
     Для управління користувачами системи реалізовано сервіс SystemAdminService. Функціонал адміністрування включає моніторинг користувачів, блокування доступу та управління ролями (RBAC).
     Реалізовані функції:
* Блокування (Toggle Status): Дозволяє адміністратору миттєво обмежити доступ користувача до системи без видалення його історичних даних. Виконується інверсія поля isActive;
* Зміна ролі (Change Role): Дозволяє динамічно змінювати рівень доступу співробітника (наприклад, DOCTOR -> ADMIN).
Фрагмент коду класу SystemAdminService.java:
@Service
public class SystemAdminService {

    private final UserRepository userRepository;

    public SystemAdminService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public User toggleUserStatus(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));
        
        if (user.getIsActive() == null) {
            user.setIsActive(true);
        }
        
        user.setIsActive(!user.getIsActive());
        return userRepository.save(user);
    }

    public User updateUserRole(Long userId, String newRole) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));
        
        user.setRole(newRole);
        return userRepository.save(user);
    }
}
     3.4. Графічні ілюстрації
     3.4.1. UML Діаграма діяльності 
     Розроблена діаграма діяльності моделює робочий процес лікаря-офтальмолога в системі OptiView. Процес складається з наступних етапів:
1. Авторизація та вибір: Лікар входить у систему та обирає пацієнта з бази;
2. Введення даних: Вносяться показники візіометрії (гострота зору);
3. Точка прийняття рішення: Система передбачає розгалуження процесу в залежності від наявності патології:
* Шлях "Так": Лікар вводить діагноз та призначає лікування. Відбувається перевірка сумісності препаратів;
* Шлях "Ні": Фіксується профілактичний огляд.
4. Завершення: Дані проходять фінальну валідацію та зберігаються в базі даних. Діаграма чітко візуалізує алгоритм дій користувача та реакцію системи на різних етапах прийому.

Рисунок 3.1 - Алгоритм проведення прийому пацієнта
     3.4.2. UML Діаграма взаємодії
     Діаграма послідовності деталізує технічну реалізацію сценарію "Збереження результатів огляду". Вона демонструє обмін повідомленнями між шарами архітектури:
1. Actor (Лікар): Ініціює подію натисканням кнопки "Зберегти";
2. View (UI): Відправляє POST-запит на сервер;
3. Controller: Приймає запит і передає DTO в сервіс;
4. Service (MedicalRecordService): Виконує бізнес-логіку (валідація, збагачення даних);
5. Repository: Генерує SQL-запит INSERT до бази даних;
6. Database: Повертає ID створеного запису, який каскадно повертається користувачеві у вигляді підтвердження успішної операції (HTTP 200 OK).

Рисунок 3.2 - Послідовність викликів при збереженні огляду
     2.5. Перевірка роботи серверної частини (Тестування)
     Перевірка функціональності здійснювалася методом чорної скриньки (Black Box Testing) за допомогою інструменту Postman. Було протестовано ключові сценарії використання API, включаючи позитивні та негативні кейси для підтвердження надійності бізнес-логіки.
     Сценарій 1: Успішне створення медичного запису (Happy Path)
* Мета: Перевірити збереження коректних даних та автоматичну генерацію полів;
* Метод: POST
* URL: http://localhost:8080/api/visits/save
* Тіло запиту (JSON):
{
  "patientId": 7,
  "diagnosis": "Міопія середнього ступеня",
  "treatment": "Окуляри -2.5D",
  "visualAcuity": "0.4/0.4"
}


Рисунок 3.3 – Результат виконання запиту медичного запису
     Результат: Отримано код відповіді 200 OK. У тілі відповіді повернувся об'єкт з автоматично згенерованим visitId, статусом COMPLETED та поточною датою, що підтверджує коректну роботу сервісу.
     Сценарій 2: Перевірка валідації даних (Негативний сценарій)
* Мета: Перевірити роботу бізнес-правила, яке забороняє створення візиту без діагнозу.
* Метод: POST
* URL: http://localhost:8080/api/visits/save
* Тіло запиту (JSON):
{
  "patientId": 6,
  "doctorId": 4,
  "diagnosis": "",
  "treatment": "Окуляри -1.5D, гімнастика для очей",
  "visualAcuity": "0.6/0.6"
}


Рисунок 3.4 – Результат перевірки валідації даних медичних записів
     Результат: Отримано код відповіді 400 Bad Request. Сервер повернув повідомлення про помилку "Diagnosis cannot be empty", що підтверджує спрацювання захисних механізмів бізнес-логіки.
     
Сценарій 3: Блокування доступу користувача (Адміністрування)
* Мета: Перевірити функцію керування доступом до системи.
* Метод: POST
* URL: http://localhost:8080/api/users/5/toggle-status
* Опис: Тестування зміни статусу для користувача з ID 5.

Рисунок 3.5 – Успішне виконання блокування доступу до системи
   Результат: Отримано код відповіді 200 OK. У базі даних Supabase поле is_active для даного користувача змінило значення з true на false, доступ успішно обмежено.

Сценарій 4: Зміна ролі користувача (Управління правами)
* Мета: Перевірити можливість динамічної зміни прав доступу (RBAC).
* Метод: POST
* URL: http://localhost:8080/api/users/5/role?role=doctor
   Результат: Отримано код відповіді 200 OK. У відповіді повернувся об'єкт користувача з оновленим полем role: "doctor".
   
   Рисунок 3.6 – Успішне виконання зміни ролі с admin на doctor

Сценарій 5: Моніторинг користувачів системи
* Мета: Отримання адміністратором повного списку облікових записів.
* Метод: GET
* URL: http://localhost:8080/api/users

Рисунок 3.7 – Успішно виконаний запрос по інформації всіх юзерів 
   Результат: Отримано код 200 OK та масив JSON-об'єктів, що містить інформацію про всіх зареєстрованих користувачів та їхні поточні статуси активності.


ДОДАТОК А
Посилання на відео-демонстрацію: https://youtu.be/hf5tG_dvT18

Хронологічний опис:
00:00 - Вступ 
00:26 - Огляд архітектури 
01:04 - Демонстрація коду бізнес-логіки 
02:36 - Тестування бізнес-логіки в Postman 
05:34 - Демонстрація функцій адміністрування

Посилання на GitHub репозиторій: https://github.com/NureKavresievMykyta/OptiView
     


2










