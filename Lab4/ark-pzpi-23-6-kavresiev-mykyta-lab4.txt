МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
до лабораторної роботи №4
з дисципліни «Аналіз та рефакторинг коду» на тему:
«РОЗРОБКА IoT КЛІЄНТА (БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ НАЛАШТУВАННЯ)»



Виконав:
ст. гр. ПЗПІ-23-6
Кавресєв Микита


Перевірив:
ас. кафедри ПІ
Дашенков Дмитро Сергійович



Харків 2025
1 ЗАВДАННЯ
     4.1 Мета роботи
     Метою лабораторної роботи є набуття практичних навичок проєктування та програмної реалізації клієнтської частини системи Інтернету речей (IoT). У ході виконання роботи необхідно:
1. Розробити архітектуру програмного забезпечення IoT-клієнта;
2. Створити UML діаграми прецедентів та діяльності;
3. Розробити бізнес-логіку клієнта (математичну обробку даних предметної області);
4. Реалізувати функції налаштування клієнта (конфігурація підключення);
5. Створити програмну реалізацію та перевірити взаємодію із серверною частиною системи OptiView.


2 ОПИС ВИКОНАНОЇ РОБОТИ
     4.2 Текстовий опис інженерних рішень
     В рамках лабораторної роботи було розроблено програмний емулятор медичного пристрою Smart Phoropter (Розумний Фороптер), який є частиною системи офтальмологічної клініки OptiView.
     Архітектурні рішення: IoT-клієнт реалізовано як настільний додаток (Desktop Application) мовою Java з використанням бібліотеки Swing для графічного інтерфейсу. Такий вибір обумовлений необхідністю повної сумісності з технологічним стеком серверної частини (Java Spring Boot) та зручністю демонстрації роботи пристрою без використання специфічного апаратного забезпечення.
     Пристрій працює за моделлю «Smart Device», що підключається до локальної мережі клініки. Він виконує роль інтелектуального терміналу для збору медичних даних.
     Методи комунікації та протоколи: взаємодія між IoT-клієнтом та сервером побудована на базі архітектурного стилю REST.
* Протокол: HTTP/1.1.
* Формат даних: JSON (JavaScript Object Notation).
* Метод передачі: POST-запити на ендпоінт /api/visits/save.
* Бібліотеки: Використано стандартний java.net.http.HttpClient, що дозволяє уникнути важких сторонніх залежностей.
     Бізнес-логіка клієнта: Основна функція пристрою — автоматизація проведення візіометрії. Замість ручного введення даних лікарем, пристрій імітує роботу оптичних сенсорів. Реалізовано алгоритм генерації медичних показників:
1. Генерація випадкових значень гостроти зору для лівого та правого ока в діапазоні [0.1; 1.0];
2. Випадковий вибір діагнозу зі списку поширених патологій (Міопія, Гіперметропія, Астигматизм) або варіант "Здоровий";
3. Автоматичне призначення рекомендацій щодо лікування на основі діагнозу;
4. Формування пакету даних (DTO) та серіалізація його у JSON-рядок; 
     Функції налаштування: Реалізовано модуль конфігурації, що дозволяє змінювати параметри роботи пристрою без необхідності перекомпіляції коду. Користувач може налаштувати:
* URL Сервера: Для перемикання між локальним середовищем розробки (localhost) та продакшн-сервером;
* ID Лікаря: Ідентифікація спеціаліста, який на даний момент працює з приладом.
     4.3 Фрагменти програмного коду
     4.3.1 Код бізнес-логіки (Обробка та генерація даних)
     У даному фрагменті наведено реалізацію методу performMeasurement, який є ядром бізнес-логіки IoT-клієнта. Оскільки пристрій розробляється як емулятор, взаємодія з фізичними сенсорами замінена на математичну генерацію правдоподібних даних (Simulation Logic).
     Алгоритм роботи методу включає наступні етапи:
1. Ініціалізація процесу: Отримання вхідного параметра (ID пацієнта) від користувача та блокування інтерфейсу для запобігання повторних натискань.
2. Емуляція апаратної затримки: Використання Thread.sleep() для імітації часу, необхідного реальним оптичним датчикам для сканування сітківки ока.
3. Генерація медичних показників (Edge Computing):
* Використання класу Random для створення значень гостроти зору в межах фізіологічної норми та відхилень (від 0.1 до 1.0);
* Випадковий вибір діагнозу з попередньо визначеного масиву;
* Логічний вивід: Автоматичне визначення необхідності лікування на основі діагнозу (наприклад, якщо діагноз "Здоровий", лікування "Не потребує"). Це демонструє здатність пристрою проводити первинну аналітику даних «на краю» (on the edge), розвантажуючи сервер.
4. Серіалізація даних: Формування JSON-рядка вручну для передачі через REST API.

private void performMeasurement() {
    String patientIdText = patientIdField.getText().trim();
    long currentPatientId = Long.parseLong(patientIdText);

    log("--- Початок вимірювання для Пацієнта #" + currentPatientId + " ---");
    
    // імітація затримки роботи апаратних сенсорів
    try { Thread.sleep(1000); } catch (InterruptedException e) {}

    String[] diagnoses = {"Міопія слабкого ступеня", "Гіперметропія", "Астигматизм", "Здоровий"};
    String diagnosis = diagnoses[random.nextInt(diagnoses.length)];

    // генерація гостроти зору
    double leftEye = 0.1 + (1.0 - 0.1) * random.nextDouble();
    double rightEye = 0.1 + (1.0 - 0.1) * random.nextDouble();
    String visualAcuity = String.format("%.1f/%.1f", leftEye, rightEye).replace(',', '.');
    
    String treatment = diagnosis.equals("Здоровий") ? "Не потребує" : "Рекомендовано окуляри/лінзи";

    // формування JSON пакету вручну
    String jsonBody = String.format(
            "{\"patientId\":%d, \"doctorId\":%d, \"diagnosis\":\"%s\", \"treatment\":\"%s\", \"visualAcuity\":\"%s\"}",
            currentPatientId, doctorId, diagnosis, treatment, visualAcuity
    );
    
    sendDataToServer(jsonBody);
}
     4.4 Код функцій налаштування 
     Наведений нижче фрагмент коду демонструє реалізацію функцій адміністрування та конфігурації IoT-пристрою. Відповідно до кращих практик розробки вбудованих систем, параметри підключення не є жорстко закодованими (hardcoded), а можуть бути змінені користувачем під час виконання програми (Runtime Configuration).
Ключові аспекти реалізації:
1. Інтерактивність: Використання діалогових вікон JOptionPane дозволяє лікарю або технічному адміністратору зручно вводити нові параметри без необхідності редагування конфігураційних файлів;
2. Гнучкість мережі: Можливість зміни serverUrl дозволяє легко перемикати пристрій між тестовим сервером (localhost) та реальним хмарним середовищем;
3. Персоналізація сесії: Зміна doctorId дозволяє використовувати один і той самий прилад різним лікарям, що відповідає вимогам багатокористувацької системи;
4. Валідація та обробка помилок: Блок try-catch забезпечує стабільність роботи емулятора, запобігаючи аварійному завершенню програми при введенні некоректних даних (наприклад, літер замість числового ID).



private void openSettings() {
    JTextField urlField = new JTextField(serverUrl);
    JTextField docIdField = new JTextField(String.valueOf(doctorId));

    Object[] message = {
            "URL Сервера:", urlField,
            "ID Лікаря (поточний користувач):", docIdField
    };

    // відображення діалогового вікна налаштувань
    int option = JOptionPane.showConfirmDialog(this, message, "Налаштування IoT Клієнта", JOptionPane.OK_CANCEL_OPTION);
    
    if (option == JOptionPane.OK_OPTION) {
        try {
            // оновлення параметрів у пам'яті пристрою
            serverUrl = urlField.getText();
            doctorId = Long.parseLong(docIdField.getText());

            infoLabel.setText("DocID: " + doctorId + " | Ready to Scan");
            log("Налаштування оновлено.");
            log("Новий URL: " + serverUrl);
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "Некоректні дані!", "Помилка", JOptionPane.ERROR_MESSAGE);
        }
    }
}
     4.5 Графічні ілюстрації
     4.5.1 UML Діаграма прецедентів ІоТ клієнта 
     Представлена діаграма прецедентів (Use Case Diagram) моделює функціональні вимоги до системи з точки зору взаємодії зовнішніх агентів із IoT-пристроєм "Smart Phoropter".
На діаграмі виділено два ключові актори:
1. Лікар-офтальмолог: Активний користувач, який ініціює всі бізнес-процеси. Він відповідає за фізичну взаємодію з пристроєм: запуск процесу вимірювання, введення даних пацієнта та зміну налаштувань.
2. Сервер OptiView: Зовнішня система, яка пасивно очікує на дані від IoT-клієнта. Взаємодія з сервером відбувається автоматично в рамках виконання внутрішніх процесів пристрою.
Основні прецеденти (Use Cases):
* Проведення вимірювання зору: Основний сценарій використання. Він включає в себе (відношення <<include>>) прецеденти формування пакету даних та відправки результатів, оскільки ці дії є невід'ємною частиною процесу вимірювання;
* Налаштування параметрів: Сценарій, що дозволяє змінювати конфігурацію пристрою (IP-адреса, ID лікаря);
* Авторизація та Відправка: Технічні прецеденти, що показують внутрішню логіку комунікації з REST API.

Рисунок 4.1 – UML діаграма прецедентів IoT клієнта
     4.5.2 UML Діаграма діяльності ІоТ клієнта 
     Діаграма діяльності (Activity Diagram) детально візуалізує алгоритмічну структуру роботи програмного забезпечення емулятора. Вона відображає динамічну поведінку системи та переходи між станами.
Логіка роботи пристрою розділена на кілька етапів:
1. Ініціалізація: При запуску система завантажує налаштування за замовчуванням та перевіряє доступність інтерфейсів.
2. Перевірка з'єднання: Система перевіряє наявність мережевого підключення. У разі помилки активується гілка обробки виключень (відображення статусу помилки), після чого система повертається в режим очікування або налаштувань.
3. Режим очікування (Idle State): Пристрій очікує на дію лікаря.
4. Обробка подій:
* При виборі "Налаштування": відкривається вікно конфігурації, відбувається валідація та збереження нових параметрів;
* При виборі "Виміряти": запускається процес емуляції сенсорів, генерація JSON-об'єкта та відправка HTTP POST запиту.
5. Обробка відповіді сервера: Діаграма показує розгалуження в залежності від HTTP-коду відповіді. Якщо отримано код 200 OK, користувач бачить повідомлення про успіх. У разі кодів 4xx або 5xx (наприклад, помилка валідації пацієнта), система логує помилку та повідомляє про неї користувача.

Рисунок 4.2 – UML діаграма діяльності
     4.6 Перевірка роботи ІоТ клієнта
     Тестування проводилося шляхом запуску емулятора Smart Phoropter та локального сервера OptiView.
Сценарій 1: Налаштування пристрою
   Дія: Користувач натиснув кнопку "Налаштування" та змінив ID лікаря з 8 на 10.

Рисунок 4.3 – Результат зміни id доктора
   Результат: Інтерфейс оновився, у логах зафіксовано зміну конфігурації.

Сценарій 2: Проведення вимірювання
Дія: Введено ID пацієнта 6, натиснуто кнопку "ВИМІРЯТИ".
Результат:
1. Емулятор згенерував випадкові дані (діагноз, гострота зору).
2. Сформовано JSON: {"patientId":6, "doctorId":10, ...}.
3. Відправлено POST-запит на сервер.
4. Отримано відповідь 200 OK від сервера.
5. У базі даних Supabase з'явився новий запис у таблиці visits.

Рисунок 4.3 – Інтерфейс емулятора після успішного вимірювання


Рисунок 4.4 – Дані збережені в базі даних Visit_id 16



3 ВИСНОВКИ
     У ході виконання лабораторної роботи було успішно спроєктовано та реалізовано програмне забезпечення для IoT-клієнта системи OptiView.
1. Розроблено емулятор пристрою "Smart Phoropter" на мові Java, який повністю імітує роботу реального медичного обладнання;
2. Реалізовано бізнес-логіку генерації медичних даних безпосередньо на клієнті ("Edge Computing"), що зменшує навантаження на лікаря;
3. Забезпечено гнучкість системи завдяки функціям налаштування підключення та ідентифікації персоналу;
4. Налаштовано надійну взаємодію з сервером через REST API, що підтверджено успішним збереженням даних у хмарній базі Supabase;
5. Створені UML діаграми повністю відповідають реалізованій логіці роботи додатку.


ДОДАТОК А
Посилання на відео-демонстрацію: https://youtu.be/u9a9wLaJgfo

Хронологічний опис:
00:00 - Вступ
00:50 - Огляд коду
05:27 - Огляд пристрою
06:10 - Підготовка до тестування
09:43 - Тестування

Посилання на GitHub репозиторій: https://github.com/NureKavresievMykyta/OptiView
     




2










